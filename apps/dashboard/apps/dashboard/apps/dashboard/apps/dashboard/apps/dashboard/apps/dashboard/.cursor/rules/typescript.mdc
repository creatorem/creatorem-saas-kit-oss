---
description: 
globs: *.tsx,*.ts
alwaysApply: false
---
# TypeScript Development Guidelines

This guide outlines best practices and patterns for TypeScript development in the project.

## Core Principles

### 1. Type Safety
- ✅ Write precise, readable, maintainable code
- ✅ Enforce strict type validation throughout
- ✅ Let compiler infer types when context is clear
- ❌ Avoid `any` type - use `unknown` when necessary

### 2. Engine Implementation
- ✅ Implement server logic as engines with factory pattern
- ✅ Use dependency injection for better testability
- ✅ Keep services focused and single-responsibility

Example:
```typescript
// userEngine.ts
class UserEngine {
  fetchUserById(userId: number) {
    // Implementation logic
    return { userId, displayName: 'User' };
  }
}

export function createUserEngine() {
  return new UserEngine();
}
```

## Type System Best Practices

### 1. Type Definitions
- ✅ Use string union types over enums when possible
- ✅ Define interfaces for complex data structures
- ✅ Leverage generics for reusable components
- ✅ Use type guards for runtime type checking

### 2. Type Safety Patterns
- ✅ Use strict null checks
- ✅ Implement proper type narrowing
- ✅ Utilize utility types effectively
- ✅ Document complex type relationships

## Architecture Patterns

### 1. Code Organization
- ✅ Design modules with single responsibilities
- ✅ Favor object composition over inheritance
- ✅ Create focused functions with clear purpose
- ✅ Choose descriptive identifiers for all elements

### 2. Error Handling
- ✅ Implement robust error handling
- ✅ Use custom error types
- ✅ Provide meaningful error messages
- ✅ Log errors with context

Example:
```typescript
async function fetchData<T>(url: string): Promise<T> {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`API error: ${response.status}`);
    }
    return await response.json() as T;
  } catch (error) {
    logger.error('Data fetch failed', { url, error });
    throw new Error('Failed to retrieve data');
  }
}
```

## Code Quality

### 1. Implementation Guidelines
- ✅ Strive for simplicity in implementation
- ✅ Consider computational efficiency
- ✅ Write composable, pure functions when possible
- ❌ Avoid side effects in unexpected places
- ✅ Prioritize readability over clever solutions

### 2. Testing
- ✅ Write unit tests for critical logic
- ✅ Use type-safe testing utilities
- ✅ Mock external dependencies
- ✅ Test error scenarios

## Performance Considerations

### 1. Optimization
- ✅ Be mindful of bundle size impacts
- ✅ Consider memory usage in data structures
- ✅ Profile code for performance bottlenecks
- ✅ Optimize only after measuring

### 2. Best Practices
- ✅ Use appropriate data structures
- ✅ Implement proper caching strategies
- ✅ Consider lazy loading when appropriate
- ✅ Monitor performance metrics

## Implementation Checklist

### 1. New Features
- [ ] Define proper types and interfaces
- [ ] Implement error handling
- [ ] Add unit tests
- [ ] Document complex logic
- [ ] Review performance impact

### 2. Code Review
- [ ] Check type safety
- [ ] Verify error handling
- [ ] Review performance considerations
- [ ] Validate documentation

Remember: TypeScript is a tool to help write better code. Use it to enforce good practices and catch errors early in development.
